# Virtual thread

가상 스레드는 java 21에서 도입된 것으로 다음과 같은 문제를 해결하고자 나타났다.

1. java 개발자가 하드웨어의 성능을 활용하는 높은 처리량의 서버를 작성하는 것

- 가상 스레드는 Blocking이 발생하면 내부적으로 스케줄링을 활영하여 플랫폼 스레드가 그냥 대기하도록 두지 않고 다른 가상 스레드가 작업할 수 있도록 한다.
- 따라서 Reactive Programming(ex: webflux)의 Non-blocking과 동일하게 플랫폼 스레드의 리소스를 낭비하지 않는다.

2. 동시에 자바 플랫폼의 디자인과의 조화를 이루는 코드를 생성할 수 있도록 하는 것

- 기존 Reactive Programming의 장점에도 불구하고 전통적인 자바 언어의 구조는 스레드를 기반으로 하였기 때문에 디버깅, 성능 테스트가 어려웠다.
- 하지만, 가상 스레드는 기존 스레드 구조를 그대로 사용하기 때문에 디버깅, 프로파일링 등 기존의 도구도 그대로 사용할 수 있다.

## Reactive Programming 과의 비교

- Reactive Programming이 달성하고자 하는, 리소스를 효율적으로 사용하여 높은 처리량을 감당하려는 목적은 동일하다.
- 가상 스레드를 사용하면 Non-blocking에 대한 처리를 JVM 레벨에서 담당한다.

## 기존 방식과의 차이

기존 플랫폼 스레드는 OS 스레드를 감싼 것이기 때문에, 
애플리케이션 코드가 플랫폼 스레드를 사용하면 실제로는 OS 스레드를 사용한다.
이 때 사용하는 스레드는 비용이 비싸기 때문에 스레드 풀 을 사용하여 접근하는 방식으로 사용한다.

반면에 가상 스레드는 OS 스레드를 감싼 구조가 아니기 때문에, 
애플리케이션 코드는 가상 스레드 풀 없이 사용하고 JVM 자체적으로 가상 스레드를 OS 스레드와 연결하는 스케줄링한다. 
이 작업을 mount / unmount 라고 하며 기존에 플랫폼 스레드라고 하던 부분을 Carrier 스레드라고 한다.
Carrier 스레드는 가상 스레드를 실제 OS 스레드와 연결해준다는 뜻이다.

기존의 스레드는 Blocking 이 발생하면 그냥 기다려야 했는데, 
가상 스레드는 Blocking이 발생하면 내부의 스케줄링을 통해 실제 작업을 처리하는 Carrier 스레드가 다른 가상 스레드의 작업을 처리한다. 
따라서 Non-blocking이 누리는 장점을 동일하게 누릴 수 있다. 